# 渲染机制
浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。

- 什么是DOCTYPE及作用
- 浏览器渲染过程
- 重排Reflow
- 重绘Repaint
- 布局Layout

## DOCTYPE及作用
DTD是一系列的语法规则，用来定义XML或者(X)HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。  
DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。

## 浏览器渲染流程
![浏览器渲染流程](../../images/浏览器渲染流程.png)
浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：
1. 解析 HTML 创建 **DOM 树**，解析 CSS（包括外部 CSS 文件和样式元素）创建的是 **CSSOM 树**。CSSOM 的解析过程与 DOM 的解析过程是并行的。
2. CSSOM 与 DOM 结合，得到的就是 **render 树**
3. 布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
4. 绘制 render 树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。  

所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了。

Q：load事件与DOMContentLoaded事件的先后？
- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)
- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）  

所以，顺序是：DOMContentLoaded -> load

Q：css加载是否会阻塞dom树渲染？
css是由单独的下载线程异步下载的。所以：
- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

## CSS 优化建议
**CSS 选择符是从右到左进行匹配的。**
- 避免使用通配符，只对需要用到的元素进行选择。
- 关注可以通过继承实现的属性，避免重复匹配重复定义。
- 少用标签选择器。如果可以，用类选择器替代。
- 减少嵌套。我们应该尽量将选择器的深度降到最低（最高不要超过三层）

## JS 引擎
JS 引擎是独立于渲染引擎存在的。**我们的 JS 代码在文档的何处插入，就在何处执行**。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 因此与其说是 JS 把 CSS 和 HTML 阻塞了，不如说是 JS 引擎抢走了渲染引擎的控制权。

### JS的三种加载方式
* 正常模式：
    ```
    <script src="index.js"></script>
    ```
    这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。
    
* async 模式：
    ```
    <script async src="index.js"></script>
    ```
    async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会**立即执行**。如果有多个async脚本，执行顺序与加载顺序无关。
 
* defer 模式：
    ```
    <script defer src="index.js"></script>
    ```
    defer 模式下，JS 的加载是异步的，执行是**被推迟的**。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始**依次**执行。如果有多个defer脚本，则按照加载顺序依次执行。
 
从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。
 
通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。


