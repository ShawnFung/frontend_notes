# 连续赋值
```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);

// 结果:
// undefined
// {n: 2}
```

## 分析
- 运算符优先级。. 的优先级高于 = (赋值)的优先级
- 赋值顺序是从右向左；
- 引用对象的变量存的是内存地址；（所有引用对象的变量，存储的都是该对象的内存地址）  

这道题的重点在第三步：
```js
a.x = a = {n: 2};
// 这里拆分出来写应该是这样的
// 1. 因为 . 优先级高于 = ，所以先解析 a.x，此时a指向的值是 {n: 1, x: undefined}，之后执行a.x = {n: 2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象。
// 2. a = {n: 2}  // 赋值操作是从右到左，a = {n: 2}，a 的引用就被改变了，然后这个返回值又赋值给了 a.x。
// 3. a.x = {n: 2}  // a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，于是{ n: 1, x: undefined} => {n: 1, x: { n: 2}}，即b.x = { n: 2 }。
```
