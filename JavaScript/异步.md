## 异步

### 一个主线程
主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。
Web Worker：工作线程。

### 函数调用栈
当函数调用栈为空时，即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行，执行的过程同样会利用函数栈。
- 单线程，依次自顶而下的执行，遇到函数就会创建函数执行上下文，并入栈
- 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈
- 函数的执行上下文的个数没有限制
- 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

### 多个任务队列
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。  
    （1）所有任务都在主线程上执行，形成一个执行栈（execution context stack）。  
    （2）主线程之外，还存在一个"任务队列"（task queue）。系统把异步任务放到"任务队列"之中，然后继续执行后续的任务。  
    （3）一旦"执行栈"中的所有任务执行完毕，系统就会读取"任务队列"。如果这个时候，异步任务已经结束了等待状态，就会从"任务队列"进入执行栈，恢复执行。  
    （4）主线程不断重复上面的第三步。  

一个js文件里事件循环只有一个，但是任务队列可以有多个。任务队列又可以分为macro-task（task）与micro-task（job）。   
macro-task（task）包括： 
- script（全局任务）
- setTimeout/setInterval
- setImmediate
- I/O操作
- UI rendering  

micro-task（job）包括： 
- process.nextTick
- Promise
- Object.observe(已废弃)
- MutationObserver(html5新特性)  

我们称他们为事件源， 事件源作为任务分发器，他们的回调函数才是被分发到任务队列，而本身会立即执行。  
 
### 事件循环 Event Loop
Q：什么是 Event Loop？  
先执行 task 任务队列中的第一个 task，再顺序执行所有的 job 并清空 job 队列。再执行1个task--所有job--1个task--所有job......,往复循环直到没有可执行代码。

Q：Vue 如何实现异步队列？
Q：在 JavaScript 中，如何模拟异步？
    setTimeout？

### Event Loop 测试题
```
setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i<10000 ; i++ ){
        i==9999 && resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
```
Q：打印的结果是：1,2,3,5,4  
考点：
- script 属于一个 macrotask；Promise 是进入 job 队列；setTimeout() 进入 task 队列。
- Event Loop 的执行顺序：1个task--所有job--1个task--所有job



### 参考文档
- [从 JS Event Loop 机制看 Vue 中 nextTick 的实现原理](http://gitbook.cn/books/5a02f569cdd0574e960b3b13/index.html?utm_source=iteyes)
